<!-- livebook:{"persist_outputs":true} -->

# Lively Demo

```elixir
Mix.install(
  [
    {:ecto, "~> 3.8"},
    {:lively, git: "https://github.com/spawnfest/lively"}
  ],
  force: true
)
```

<!-- livebook:{"output":true} -->

```
* Getting lively (https://github.com/spawnfest/lively)
remote: Enumerating objects: 112, done.        
remote: Counting objects: 100% (112/112), done.        
remote: Compressing objects: 100% (71/71), done.        
remote: Total 112 (delta 55), reused 92 (delta 35), pack-reused 0        
origin/HEAD set to main
Resolving Hex dependencies...
Dependency resolution completed:
New:
  connection 1.1.0
  db_connection 2.4.2
  decimal 2.0.0
  ecto 3.9.1
  ecto_sql 3.9.0
  kino 0.7.0
  table 0.1.2
  telemetry 1.1.0
* Getting ecto (Hex package)
* Getting kino (Hex package)
* Getting ecto_sql (Hex package)
* Getting db_connection (Hex package)
* Getting telemetry (Hex package)
* Getting connection (Hex package)
* Getting table (Hex package)
* Getting decimal (Hex package)
==> connection
Compiling 1 file (.ex)
Generated connection app
==> decimal
Compiling 4 files (.ex)
Generated decimal app
==> table
Compiling 5 files (.ex)
Generated table app
==> kino
Compiling 36 files (.ex)
Generated kino app
===> Analyzing applications...
===> Compiling telemetry
==> db_connection
Compiling 14 files (.ex)
Generated db_connection app
==> ecto
Compiling 56 files (.ex)
Generated ecto app
==> ecto_sql
Compiling 25 files (.ex)
Generated ecto_sql app
==> lively
warning: the dependency :lively requires Elixir "~> 1.14" but you are running on v1.14.0-rc.0
Compiling 7 files (.ex)
Generated lively app
```

<!-- livebook:{"output":true} -->

```
:ok
```

## Lively - Ecto utilities for Livebook

Lively is a collection of utilities for working with Ecto and Livebook.

Existing components:

* `Lively.EntityRelationship`: Visualize your `Ecto.Schema` as an ER diagram
* `Lively.Explain`: Visualize the query plan for an `Ecto.Query` (only Postgres support for now). See [guides/explain.livemd](guides/explain.livemd) for examples.
* `Lively.ChangesetValidator`: Visualize an `Ecto.Changeset` by passing a changeset function and its attributes. 
* `Lively.QueryBuilder`: Build and return an Ecto.Query from the SQL query passed in the params. (Unfinished)
A next step here would be having a SmartCell rendered for changing attributes and a better looking result of changeset evaluation.

### Entity Relantionship Diagram from Schemas

```elixir
defmodule Organization do
  use Ecto.Schema

  schema "organizations" do
    field(:name, :string)
    has_one(:team, Team)
  end
end

defmodule Team do
  use Ecto.Schema

  schema "teams" do
    field(:name, :string)
    has_many(:persons, Person)
  end
end

defmodule Person do
  use Ecto.Schema

  schema "persons" do
    field(:name, :string)
    field(:age, :integer)

    has_one(:team, Team)
    belongs_to(:organization, Organization)
  end
end

%Lively.EntityRelationship{schema: Person}
```

<!-- livebook:{"output":true} -->

```
Person
```

### Changeset Validator from Schemas

```elixir
defmodule TestUser do
  use Ecto.Schema
  import Ecto.Changeset

  schema "users" do
    field :name, :string
    field :age, :integer, default: 0
    field :email, :string
  end

  def changeset(user, attrs) do
    user
    |> cast(attrs, [:name, :age, :email])
    |> validate_required(:name)
    |> validate_format(:email, ~r/@/)
    |> validate_inclusion(:age, 18..100)
  end

  def another_changeset(user, attrs) do
    user
    |> cast(attrs, [:name, :age, :email])
    |> validate_required(:name)
    |> validate_format(:email, ~r/@/)
    |> validate_inclusion(:age, 21..100)
  end
end

args = %{
      name: "John",
      age: -1,
      email: "this.is.wrong.com"
  }

%Lively.ChangesetValidator{fun: &TestUser.changeset/2, attrs: args}
```

<!-- livebook:{"output":true} -->

```
Changeset valid? false.

Errors: [age: {"is invalid", [validation: :inclusion, enum: 18..100]}, email: {"has invalid format", [validation: :format]}].
```

### Generate Ecto Query from SQL

```elixir
defmodule TestUser do
  use Ecto.Schema
  import Ecto.Changeset

  schema "users" do
    field :name, :string
    field :age, :integer, default: 0
    field :email, :string
  end
end


%Lively.QueryBuilder{sql_query: "SELECT * FROM users WHERE name = 'John'"}
```
