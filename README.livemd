# Lively Demo

```elixir
Mix.install(
  [
    {:ecto, "~> 3.8"},
    {:lively, git: "/Users/filipe/workspace/lively"}
  ],
  force: true
)
```

## Lively - Ecto utilities for Livebook

Lively is a collection of utilities for working with Ecto and Livebook.

Existing components:

* `Lively.EntityRelationship`: Visualize your `Ecto.Schema` as an ER diagram
* `Lively.Explain`: Visualize the query plan for an `Ecto.Query`.
* `Lively.ChangesetValidator`: Visualize an `Ecto.Changeset` by passing a changeset function and its attributes.
  A next step here would be having a SmartCell rendered for changing attributes and a better looking result of changeset evaluation.
* `Lively.QueryBuilder`: Build and return an Ecto.Query from the SQL query passed in the params. (Unfinished)

## Entity Relationship Diagram

Using the `%Lively.EntityRelantionship{schema: Module}` you will be able to visualize a Entity Relationship Diagram and connected entities based on your Ecto.Schema.

### Example:

```elixir
defmodule Organization do
  use Ecto.Schema

  schema "organizations" do
    field(:name, :string)
    has_one(:team, Team)
  end
end

defmodule Team do
  use Ecto.Schema

  schema "teams" do
    field(:name, :string)
    has_many(:persons, Person)
  end
end

defmodule Person do
  use Ecto.Schema

  schema "persons" do
    field(:name, :string)
    field(:age, :integer)

    has_one(:team, Team)
    belongs_to(:organization, Organization)
  end
end

%Lively.EntityRelationship{schema: Person}
```

## Explain

With a given plan, you are able to draw a graph to better visualize the result of your query analysis using `Lively.Explain.new(plan)`.

You can also use `Lively.Explain.call(MyApp.Repo, :all, my_ecto_query)` so it's easier to run the plan and output the graph in one go.

**Note**: Only Postgres is supported at the moment

### Example

```elixir
plan = [
  %{
    "Plan" => %{
      "Actual Loops" => 1,
      "Actual Rows" => 4,
      "Actual Startup Time" => 0.139,
      "Actual Total Time" => 0.231,
      "Node Type" => "Result",
      "Plan Rows" => 7,
      "Plan Width" => 405,
      "Plans" => [
        %{
          "Actual Loops" => 1,
          "Actual Rows" => 4,
          "Actual Startup Time" => 0.131,
          "Actual Total Time" => 0.218,
          "Node Type" => "Append",
          "Parent Relationship" => "Outer",
          "Plan Rows" => 7,
          "Plan Width" => 405,
          "Plans" => [
            %{
              "Actual Loops" => 1,
              "Actual Rows" => 0,
              "Actual Startup Time" => 0.009,
              "Actual Total Time" => 0.009,
              "Alias" => "paris",
              "Filter" => "(ar_num = 8)",
              "Index Cond" => "(tags ? 'tourism'::text)",
              "Index Name" => "idx_paris_tags",
              "Node Type" => "Index Scan",
              "Parent Relationship" => "Member",
              "Plan Rows" => 1,
              "Plan Width" => 450,
              "Relation Name" => "paris",
              "Scan Direction" => "NoMovement",
              "Startup Cost" => 0.0,
              "Total Cost" => 8.27
            },
            %{
              "Actual Loops" => 1,
              "Actual Rows" => 0,
              "Actual Startup Time" => 0.001,
              "Actual Total Time" => 0.001,
              "Alias" => "paris",
              "Filter" => "((tags ? 'tourism'::text) AND (ar_num = 8))",
              "Node Type" => "Seq Scan",
              "Parent Relationship" => "Member",
              "Plan Rows" => 1,
              "Plan Width" => 450,
              "Relation Name" => "paris_linestrings",
              "Startup Cost" => 0.0,
              "Total Cost" => 11.8
            },
            %{
              "Actual Loops" => 1,
              "Actual Rows" => 0,
              "Actual Startup Time" => 0.003,
              "Actual Total Time" => 0.003,
              "Alias" => "paris",
              "Filter" => "(ar_num = 8)",
              "Index Cond" => "(tags ? 'tourism'::text)",
              "Index Name" => "idx_paris_points_tags",
              "Node Type" => "Index Scan",
              "Parent Relationship" => "Member",
              "Plan Rows" => 1,
              "Plan Width" => 450,
              "Relation Name" => "paris_points",
              "Scan Direction" => "NoMovement",
              "Startup Cost" => 0.0,
              "Total Cost" => 8.27
            },
            %{
              "Actual Loops" => 1,
              "Actual Rows" => 0,
              "Actual Startup Time" => 0.002,
              "Actual Total Time" => 0.002,
              "Alias" => "paris",
              "Filter" => "(ar_num = 8)",
              "Index Cond" => "(tags ? 'tourism'::text)",
              "Index Name" => "idx_paris_polygons_tags",
              "Node Type" => "Index Scan",
              "Parent Relationship" => "Member",
              "Plan Rows" => 1,
              "Plan Width" => 450,
              "Relation Name" => "paris_polygons",
              "Scan Direction" => "NoMovement",
              "Startup Cost" => 0.0,
              "Total Cost" => 8.27
            },
            %{
              "Actual Loops" => 1,
              "Actual Rows" => 0,
              "Actual Startup Time" => 0.103,
              "Actual Total Time" => 0.103,
              "Alias" => "paris",
              "Filter" => "((tags ? 'tourism'::text) AND (ar_num = 8))",
              "Node Type" => "Seq Scan",
              "Parent Relationship" => "Member",
              "Plan Rows" => 1,
              "Plan Width" => 513,
              "Relation Name" => "paris_linestrings_ar_08",
              "Startup Cost" => 0.0,
              "Total Cost" => 7.27
            },
            %{
              "Actual Loops" => 1,
              "Actual Rows" => 4,
              "Actual Startup Time" => 0.009,
              "Actual Total Time" => 0.085,
              "Alias" => "paris",
              "Filter" => "((tags ? 'tourism'::text) AND (ar_num = 8))",
              "Node Type" => "Seq Scan",
              "Parent Relationship" => "Member",
              "Plan Rows" => 1,
              "Plan Width" => 72,
              "Relation Name" => "paris_points_ar_08",
              "Startup Cost" => 0.0,
              "Total Cost" => 5.16
            },
            %{
              "Actual Loops" => 1,
              "Actual Rows" => 0,
              "Actual Startup Time" => 0.007,
              "Actual Total Time" => 0.007,
              "Alias" => "paris",
              "Filter" => "((tags ? 'tourism'::text) AND (ar_num = 8))",
              "Node Type" => "Seq Scan",
              "Parent Relationship" => "Member",
              "Plan Rows" => 1,
              "Plan Width" => 450,
              "Relation Name" => "paris_polygons_ar_08",
              "Startup Cost" => 0.0,
              "Total Cost" => 1.08
            }
          ],
          "Startup Cost" => 0.0,
          "Total Cost" => 50.11
        }
      ],
      "Startup Cost" => 0.0,
      "Total Cost" => 50.13
    },
    "Execution Time" => 1.238,
    "Planning Time" => 0.92,
    "Triggers" => []
  }
]

Lively.Explain.new(plan)
```

## Changeset Validator

A simpler way to visualize errors of applying changes to an entity using the changeset results. To use it you just need to create a struct `%ChangesetValidator{fun: Module.changeset_func/arity, attrs: attrs}`

### Example

```elixir
defmodule User do
  use Ecto.Schema
  import Ecto.Changeset

  schema "users" do
    field(:name, :string)
    field(:age, :integer)
    field(:address, :string)
  end

  def new_user_changeset(name, age) do
    params = %{name: name, age: age}

    %__MODULE__{}
    |> cast(params, [:name, :age])
    |> validate_required([:name])
    |> validate_inclusion(:age, 18..100)
  end
end

%Lively.ChangesetValidator{fun: &User.new_user_changeset/2, attrs: ["John Doe", 13]}
```

### Generate Ecto Query from SQL

```elixir
defmodule TestUser do
  use Ecto.Schema
  import Ecto.Changeset

  schema "users" do
    field :name, :string
    field :age, :integer, default: 0
    field :email, :string
  end
end


%Lively.QueryBuilder{sql_query: "SELECT * FROM users WHERE name = 'John'"}
```
